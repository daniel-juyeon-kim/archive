## MVCC(Multi-Version Concurrency Control)

lock에서 read write 블로킹을 해결하기 위해 사용한다.

마지막에 커밋된 데이터만 읽는다.

트랜잭션을 실행하면서 발생한 변경사항은 트랜잭션의 별도 공간에 저장하다가 커밋할 때 적용한다. 롤백시 변경사항이 폐기된다.

write lock은 커밋 후 해제된다.

이러한 추가적인 공간을 필요로한다.

MySQL에서 특정 시점에 커밋된 데이터를 읽는 것을 **"Consistent Read"**라고 한다.

### MVCC와 격리 수준(Isolation Levels)

MVCC에서 트랜잭션이 읽는 값은 격리 수준과 데이터를 참조하는 시점에 따라 달라진다.

#### Read Committed

가장 최근에 커밋된 데이터를 읽는다.

#### Repeatable Read

트랜잭션이 시작된 시점에 커밋된 데이터를 읽는다.(읽기 결과가 항상 같아야하기 때문)

#### Serializable

결과는 Repeatable Read와 유사하다.

MySQL은 MVCC보다 락으로 동작한다.

PostgreSQL은 MVCC 기반 접근 방식인 SSI(Serializable Snapshot Isolation)를 사용한다.(먼저 커밋된 내역을 적용시키는 방식, 스냅샷의 내용과 다르면 롤백한다.)

#### Read Uncommitted

MVCC는 커밋된 데이터를 읽기 때문에 MVCC가 적용되지 않는다.

MySQL은 MVCC가 주로 Read Committed와 Repeatable Read에 적용된다.

PostgreSQL은 READ UNCOMMITTED가 존재하지만, READ COMMITTED처럼 동작한다.

### Lost Update 이상 현상

x = 50, y = 10

tx1: x에서 y로 40이체\
tx2: x에 30입금

#### Read Committed (PostgreSQL)에서 lost update

![alt text](<05-04. mvcc read committed.drawio.svg>)

tx1에서 lost update 발생

#### Repeatable Read (PostgreSQL)로 해결

![alt text](<05-04. mvcc read committed solved .drawio.svg>)

PostgreSQL에서 repeatable read일 때, 같은 데이터에 대해 먼저 update된 tx이 커밋되면 나중 tx는 롤백한다. 즉 연관된 트랜잭션도 repeatable read여야 한다.

#### MySQL에서의 Lost Update 문제 해결

MySQL은 read, write lock을 사용해 해결한다.

- `SELECT ... FOR UPDATE`: write lock
- `SELECT ... FOR SHARE`: read lock

MySQL에서는 `SELECT` 문에 `FOR UPDATE`를 추가하여 **잠금 읽기(locking reads)**를 명시적으로 사용한다.

`FOR UPDATE`를 사용하면 선택된 데이터에 **write lock(exclusive lock)**을 건다.

`FOR UPDATE`를 사용할 경우, MySQL의 잠금 읽기는 격리 레벨과 관계없이 항상 가장 최근에 커밋된 데이터를 읽는다.

#### Write Skew(쓰기 비대칭) 문제

MySQL은 읽기에서도 `FOR UPDATE`를 사용해 해결한다.

PostgreSQL는 SSI(Serializable Snapshot Isolation)를 사용해 해결한다.

#### Serializable

격리성 레벨이 Serializable이면 이상 현상이 발생하지 않는다.

MySQL은 트랜잭션 내의 모든 일반 SELECT 문을 암묵적으로 SELECT ... FOR SHARE 작업으로 간주하여, MVCC가 아닌 락을 통해 직렬성을 강제합니다.

PostgreSQL은 **SSI(Serializable Snapshot Isolation)**를 사용하여 Serializable을 구현한다.
