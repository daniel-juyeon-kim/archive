## concurrency control

### lost update

여러 트랜잭션이 수행될때 하나의 트랜잭션의 수행이 사리지는 현상

### operation

하나의 연산 e.g. write(a)

### schedule

동시에 실행되는 여러 트랜잭션의 operation 실행 순서다. 트랜잭션 내에 operation들의 순서는 바뀌지 않는다.

### serial schedule

트랜잭션들이 겹치지 않고 실행되는 schedule이다. 동시성이 낮아서(한번에 하나의 트랜잭션만 실행) 성능이 낮다. "serializable"이나 "serializablity"라고 한다.

### non serial schedule

트랜잭션이 겹쳐 operation이 섞여서 실행되는 schedule이다. 동시성이 높아 성능이 높지만 상황에 따라 이상한 결과가 나올 수 있다.

### conflict

서로 다른 트랜잭션의 두 operation이 같은 데이터에 하나 이상 write operation이면 해당 operation은 conflict라고 한다.

`r1(a)` `w1(a)` <u>`r2(b)` `w2(b)` `c2`</u> `r1(b)` **`w1(b)`** `c1`

> 밑줄은 tx2다.

`w1(b)`로 tx2의 작업이 lost update되었다.

`r2(b) w1(b)`, `w2(b) r1(b)`, `w2(b) w1(b)`는 conflict다.\
`r2(b) w1(b)`, `w2(b) r1(b)`는 read write conflict, `w2(b) w1(b)`는 write write conflict다.

conflict operation은 순서가 바뀌면 결과도 바뀐다.

> `r1(a = 100)` `w2(a = 50)`\
> `w2(a = 50)` `r1(a = 100)`

### conflict equivalent

두 schedule의 트랜잭션이 같고 모든 conflict operation의 순서가 동일하면 conflict equivalent라고 한다.

1. <u>`r2(b)` `w2(b)` `c2`</u> `r1(a)` `w1(a)` `r1(b)` `w1(b)` `c1`
2. `r1(a)` `w1(a)` <u>`r2(b)` `w2(b)` `c2`</u> `r1(b)` `w1(b)` `c1`

1번과 2번 둘 다 `w2(a) 중략 w1(a)`가 있어 conflict equivalent하다.

1번은 serial schedule이고 2번이 conflict equivalent한데 이때 2번을 conflict serializable하다 라고 한다. 즉 serial schedule과 conflict equivalent하면 conflict serializable이다.

보통 여러 트랜잭션을 동시에 실행해도 conflict serializable 하도록 설정한다.

concurrency control은 어떤 schedule도 serializable하게 하는 것을 의미한다.
트랜잭션의 [Isolation](#isolation격리성) 속성이 이에 해당되며 개발자는 isolation level로 Isolation을 제어한다.

## recoverablity

### unrecoverable schedule

`r1(a = 100)` `w1(a = 80)` <u>`r2(b = 200)` `w2(b = 230)`</u> `r1(b = 230)` `w1(b = 250)` `c1` <u>`abort2(b = 200)`</u>

> tx2가 쓴 후 tx1이 쓰고 커밋, tx2 롤백 (tx1이 커밋해서 tx2는 롤백 불가)

tx2가 rollback해야 하지만 이미 commit한 tx1의 작업은 durablity속성 때문에 rollback할 수 없다.

schedule에서 트랜잭션이 롤백하는데 이전에 write한 데이터를 다른 트랜잭션이 읽고 커밋한 경우 unrecoverable schedule이라 한다.

rollback을 해도 이전상태로 회복 불가능할 수 있기에 DBMS가 허용하면 안된다.

### recoverable schedule

`r1(a = 100)` `w1(a = 80)` <u>`r2(b = 200)` `w2(b = 230)`</u> `r1(b = 230)` `w1(b = 250)` <u>`c2`</u> `c1`\
`r1(a = 100)` `w1(a = 80)` <u>`r2(b = 200)` `w2(b = 230)`</u> `r1(b = 230)` `w1(b = 250)` <u>`abort2`</u> `abort1`

> tx2가 쓴 데이터를 tx1이 쓴 후 커밋/롤백하고 tx1이 커밋/롤백함, 즉 트랜잭션의 **실행과 종료(커밋/롤백)가** 스택처럼 돌아가야함

tx2가 롤백하면서 tx1도 롤백해야한다. 이를 cascade rollback이라 한다. 연쇄적으로 롤백이 일어나 처리비용이 크다. 이를 cascade rollback이라 한다.

schedule내에서 어떤 트랜잭션도 자신이 읽은 데이터를 write한 트랜잭션이 먼저 커밋/롤백 전 까지는 커밋하지 않는 경우 recoverable schedule이라 한다.

### cascadeless schedule, avoid cascading rollback

cascade rollback을 피하기 위해 이런 방법을 생각했다.

`r1(a = 100)` `w1(a = 80)` <u>`r2(b = 200)` `w2(b = 230)` `c2`</u> `r1(b = 230)` `w1(b = 250)` `c1`\
`r1(a = 100)` `w1(a = 80)` <u>`r2(b = 200)` `w2(b = 230)` `abort2`</u> `r1(b = 230)` `w1(b = 250)` `abort1`

> 스케줄에서 모든 트랜잭션이 스택처럼 돌아감

schedule내에서 어떤 트랜잭션도 커밋되지 않은 트랜잭션들이 write한 데이터는 읽지 않는 경우 cascadeless schedule, avoid cascading rollback이라 한다.

### strict schedule

> 모든 트랜잭션이 분리되어있는 스케줄, 모든 트랜잭션간 오퍼레이션이 섞이지 않는다.

schedule내에서 어떤 트랜잭션도 커밋되지 않은 트랜잭션들이 write한 데이터는 읽지도 쓰지도 않는 경우 strict schedule이라 한다.

### 정리

unrecoverable schedule은 회복 불가라 DBMS에서 허용 X, recoverable schedule은 O

recoverable schedule ⊃ cascadeless schedule ⊃ strict schedule
