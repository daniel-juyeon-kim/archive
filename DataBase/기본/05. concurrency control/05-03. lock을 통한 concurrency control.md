## Lock

여러 트랜잭션에서 동일한 데이터에 read, write하면 예상치 못한 동작, 데이터 불일치가 발생한다. 그래서 lock을 사용한다.

### write lock(exclusive lock)

다른 트랜잭션이 read, write 금지

### read lock(shared lock)

다른 트랜잭션이 read 가능, write 금지

lock을 사용해도 non serializable한 문제가 발생한다.

tx1: x + y를 y에 저장\
tx2: x + y를 x에 저장

serial schedule:

tx1 → tx2: x = 300, y = 500\
tx2 → tx1: x = 400, y = 300

x = 300, y = 300

![alt text](<05-03. non serializable lock.drawio.svg>)

그래서 serializability를 보장하기 위해 2PL을 사용한다.

## Two-Phase Locking, 2PL 프로토콜

![alt text](<05-03. 2pl.drawio.svg>)

2PL은 **expanding phase(growing phase, lock을 취득하는 단계)**, **shrinking phase(contracting phase, unlock하는 단계)**로 나눠 트랜잭션을 실행한다. 즉 마지막 lock은 최초 unlock보다 먼저 실행된다.

### expanding phase(growing phase)

lock을 **취득** 하는 단계

### shrinking phase(contracting phase)

![alt text](<05-03. 2pl deadlock.drawio.svg>)

취득한 lock을 **unlock** 하는 단계, 문제는 deadlock이 발생할 수 있다.

## 2PL의 종류

### Conservative 2PL(보수적 2PL)

트랜잭션에서 필요한 모든 lock을 먼저 취득한 후 트랜잭션을 실행한다. deadlock에서 자유롭지만 실용적이지 않음 → 동시성 저하

### Strict 2PL, S2PL

락을 취득하는것은 일반적인 2PL과 같지만 write lock을 커밋/롤백이 끝나고 unlock한다.

- strict schedule 보장
- recoverablity 보장

### Strong Strict 2PL, SS2PL 또는 Rigorous 2PL (강한 엄격 2PL)

read lock, write lock을 커밋/롤백이 끝나고 unlock한다.

- strict schedule 보장
- recoverablity 보장

## 문제점

안전하지만 처리량이 낮아 read write가 블로킹하는 것을 해결하기 위해 MVCC (Multi-Version Concurrency Control)를 사용한다.
